/*
 * Copyright (C) 2017 by Shan Daming
 */

#include <algorithm>
#include <deque>
#include <cassert>
#include <thread>
#include "events.h"

namespace 
{
	struct Invoked_function_data
	{
		Invoked_function_data(bool finished_, 
				const std::function<void(void)>& func) :
			finished(finished_),
			f(func)
		{}

		void call()
		{
			f();
			finished = true;
		}

		bool finished;
		const std::function<void(void)>& f;
	};

	template<typename T>
	struct Reversion
	{
		T& iterable;
	};

	template<typename T>
	auto begin(Reversion<T>& t)
	{
		return std::rbegin(t.iterable);
	}

	template<typename T>
	auto end(Reversion<T>& t)
	{
		return std::rend(t.iterable);
	}

	template<typename T>
	Reversion<T> reverse(T&& iterable)
	{
		return {iterable};
	}
}


namespace events
{
        void Context::add_handler(Sdl_handler* ptr)
        {
	        // 最初将新的处理程序添加到staging list中，这确保如果事件处理
			// 程序添加更多处理程序，the new handlers won't be called for 
			// the event that caused them to be added.
	        staging_handlers.push_back(ptr);
        }

        bool Context::remove_handler(Sdl_handler* ptr)
        {
	        static int depth = 0;
	        ++depth;

	        // The handler is most likely on the back of the evnets list, so
			// look there first, otherwise do a complete search.
	        if(!handlers.empty() && handlers.back() == ptr)
	        {
		        if(focused_handler != handlers.end() && 
						*focused_handler == ptr)
					focused_handler = handlers.end();
		        handlers.pop_back();
	        }
	        else
	        {
		        auto it = std::find(handlers.begin(), handlers.end(), ptr);
		        if(it != handlers.end())
		        {
			        --depth;

			        // The handler may be in the staging area. Search it 
					// from there.
			        auto iter = std::find(staging_handlers.begin(), 
					        staging_handlers.end(), ptr);
			        if(iter != staging_handlers.end())
			        {
				        staging_handlers.erase(iter);
				        return true;
			        }
			        else
				        return false;
		        }
		        if(it == focused_handler)
			        focused_handler != handlers.begin() ? 
						--focused_handler : ++focused_handler;
		        handlers.erase(it);
	        }
	        --depth;

	        if(depth == 0)
		        cycle_focus();
	        else
		        focused_handler = handlers.end();

	        return true;
        }

        void Context::cycle_focus()
        {
	        if(handlers.begin() == handlers.end())
		        return;

	        auto current = focused_handler;
	        auto last = focused_handler;

	        if(last != handlers.begin())
		        --last;
	        if(current == handlers.end())
		        current = handlers.begin();
	        else
		        ++current;

	        while(current != last)
	        {
		        if(current != handlers.end() && 
						(*current)->requires_event_focus())
		        {
			        focused_handler = current;
			        break;
		        }

		        if(current == handlers.end())
			        current = handlers.begin();
		        else
			        ++current;
	        }
        }

        void Context::set_focus(const Sdl_handler* ptr)
        {
	        auto it = std::find(handlers.begin(), handlers.end(), ptr);
	        if(it != handlers.end() && (*it)->requires_event_focus())
		        focused_handler = it;
        }

        void Context::add_staging_handlers()
        {
	        if(staging_handlers.empty())
		        return;

	        std::copy(staging_handlers.begin(), staging_handlers.end(),
			        std::back_inserter(handlers));
	        staging_handlers.clear();
        }

        Context::~Context()
        {
	        for(Sdl_handler* h : handlers)
	        {
		        if(h->has_joined())
			        h->has_joined_ = false;
		        if(h->has_joined_global())
			        h->has_joined_global_ = false;
	        }
        }


        /*
         * This object stores all the event hadlers. It is a stack of event	
         * 'contexts'. a new event context is created when e.g. a modal 
		 * dialog is opened, and then closed when that dialog is closed. 
		 * Each context contains a list of the handlers in that context. 
		 * The current context is the one on the top of the stack. The 
		 * global context must always be in the first position.
         */
        std::deque<Context> event_contexts(1);

        std::vector<Pump_monitor*> pump_monitors;

        Pump_monitor::Pump_monitor()
        {
	        pump_monitors.push_back(this);
        }

        Pump_monitor::~Pump_monitor()
        {
	        pump_monitors.erase(std::remove(pump_monitors.begin(), 
				        pump_monitors.end(), this), pump_monitors.end());
        }

        /* Event_context */

        Event_context::Event_context()
        {
	        event_contexts.emplace_back();
        }

        Event_context::~Event_context()
        {
	        assert(event_contexts.empty() == false);
	        event_contexts.pop_back();
        }

        /* SDL_handler */

        Sdl_handler::Sdl_handler(bool auto_join) : has_joined_(false), 
	        has_joined_global_(false)
        {
	        if(auto_join)
	        {
		        assert(!event_contexts.empty());
		        event_contexts.back().add_handler(this);
		        has_joined_ = true;
	        }
        }

        Sdl_handler::~Sdl_handler()
        {
	        if(has_joined_)
		        leave();
	        if(has_joined_global_)
		        leave_global();
        }

        void Sdl_handler::join()
        {
	        // this assert will fire if someone will inadvertently try to 
			// join an event context but might end up in the global context
			// instead.
	        assert(&event_contexts.back() != &event_contexts.front());
	        join(event_contexts.back());
        }

        void Sdl_handler::join(Context& c)
        {
	        if(has_joined_global_)
		        leave_global();
	        if(has_joined_)
		        leave(); // should not be in multiple event contexts.

	        // join self
	        c.add_handler(this);

	        // instruct members to join
	        for(auto m : handler_members())
		        m->join(c);
        }

        void Sdl_handler::join_same(Sdl_handler* parent)
        {
	        if(has_joined_)
		        leave(); // should not be in multiple event contexts.

	        for(auto& context : reverse(event_contexts))
	        {
		        handler_list& handlers = context.handlers;
		        if(std::find(handlers.begin(), handlers.end(), parent) != 
				        handlers.end())
		        {
			        join(context);
			        return;
		        }
	        }

	        join(event_contexts.back());
        }

        void Sdl_handler::leave()
        {
	        sdl_handler_vector members = handler_members();
	        if(members.empty())
		        assert(event_contexts.empty() == false);

	        for(auto m : members)
		        m->leave();

	        for(auto& c : reverse(event_contexts))
	        {
		        if(c.remove_handler(this))
			        break;
	        }

	        has_joined_ = false;
        }

        void Sdl_handler::join_global()
        {
	        if(has_joined_)
		        leave();

	        if(has_joined_global_)
		        leave_global(); // should not be in multiple event contexts.

	        // join self
	        event_contexts.front().add_handler(this);
	        has_joined_global_ = true;

	        // instruct members to join
	        for(auto m : handler_members())
		        m->join_global();
        }

        void Sdl_handler::leave_global()
        {
	        for(auto m : handler_members())
		        m->leave_global();

	        event_contexts.front().remove_handler(this);

	        has_joined_global_ = false;
        }


        void focus_handler(const Sdl_handler* ptr)
        {
	        if(!event_contexts.empty())
		        event_contexts.back().set_focus(ptr);
        }

        bool has_focus(const Sdl_handler* ptr, const SDL_Event* event)
        {
	        if(event_contexts.empty())
		        return true;

	        if(ptr->requires_event_focus(event) == false)
		        return true;

	        auto it = event_contexts.back().focused_handler;
	        auto& handlers = event_contexts.back().handlers;

	        // If no-one has focus at the moment, this handler obviously 
			// wants focus, so give it to it
	        if(it == handlers.end())
	        {
		        focus_handler(ptr);
		        return true;
	        }

	        Sdl_handler* const foc_hand = *it;
	        if(foc_hand == ptr)
		        return true;
	        else if(!foc_hand->requires_event_focus(event))
	        {
		        // If the currently focused handler doesn't need focus for 
				// this event allow the most recent interested hanler to 
				// take care of it
		        for(auto i = handlers.rbegin(); i != handlers.rend(); ++i)
		        {
			        Sdl_handler* const thief_hand = *i;

			        if(thief_hand != foc_hand && 
					        thief_hand->requires_event_focus(event))
			        {
				        // Steal focus
				        focus_handler(thief_hand);

				        // Position the previously focused handler to allow 
				        // stealing back
				        handlers.splice(handlers.end(), handlers, it);
				        return thief_hand == ptr;
			        }
		        }
	        }
	        return true;
        }

        constexpr uint32_t resize_timeout = 100;
        SDL_Event last_resize_event;
        bool last_resize_event_used = true;

        static bool remove_on_resize(const SDL_Event& a)
        {
	        if(a.type == SHOW_HELPTIP_EVENT)
		        return true;
	        if(a.type == SDL_WINDOWEVENT && 
			        (a.window.event == SDL_WINDOWEVENT_RESIZED ||
			         a.window.event == SDL_WINDOWEVENT_SIZE_CHANGED ||
			         a.window.event == SDL_WINDOWEVENT_EXPOSED))
		        return true;
	        return false;
        }

		void initialise() { /* Add things as necessary */ }

		void finalize() { /* Add things as necessary */ }

        static const std::thread::id main_thread = 
			std::this_thread::get_id();

        void run_event_loop()
        {
	        if(std::this_thread::get_id() != main_thread)
		        // can only call this on the main thread
		        return;

	        peek_for_resize();
	        Pump_info info;

	        // Used to keep track of double click events
	        static int last_mouse_down = -1;
	        static int last_click_x = -1, last_click_y = -1;

	        SDL_Event temp_event;
	        int poll_count = 0;
	        int begin_ignoring = 0;

	        std::vector<SDL_Event> events;
	        
	        while(SDL_PollEvent(&temp_event))
	        {
		        if(temp_event.type == INVOKE_FUNCTION_EVENT)
		        {
			        static_cast<Invoked_function_data*>(
					        temp_event.user.data1)->call();
			        continue;
		        }
		        ++poll_count;
		        peek_for_resize();

		        if(!begin_ignoring && temp_event.type == SDL_WINDOWEVENT &&
				        (temp_event.window.event == SDL_WINDOWEVENT_ENTER ||
				         temp_event.window.event == SDL_WINDOWEVENT_FOCUS_GAINED))
			        begin_ignoring = poll_count;
		        else if(begin_ignoring > 0 && is_input(temp_event))
			        // ignore user input events that occurred after the 
					// window was activated
			        continue;

		        events.push_back(temp_event);
	        }

	        std::vector<SDL_Event>::iterator ev_it = events.begin();
	        for(int i = 1; i != begin_ignoring; ++i)
	        {
		        if(is_input(*ev_it))
			        // ignore user input events that occurred before the 
					// window was activated
			        ev_it = events.erase(ev_it);
		        else
			        ++ev_it;
	        }

	        std::vector<SDL_Event>::iterator ev_end = events.end();
	        bool resize_found = false;
	        for(ev_it = events.begin(); ev_it != ev_end; ++ev_it)
	        {
		        SDL_Event& event = *ev_it;
		        if(event.type == SDL_WINDOWEVENT &&
				        event.window.event == SDL_WINDOWEVENT_RESIZED)
		        {
			        resize_found = true;
			        last_resize_event = event;
			        last_resize_event_used = false;
		        }
	        }

	        // remve all inputs, draw events and only keep the last of the 
			// resize events This will turn horrible after ~38 days when 
			// the uint32_t wrasp
	        if(resize_found || SDL_GetTicks() <= 
			        last_resize_event.window.timestamp + resize_timeout)
		        events.erase(std::remove_if(events.begin(),
					        events.end(),
					        remove_on_resize),
				        events.end());
	        else if(SDL_GetTicks() > last_resize_event.window.timestamp +
			        resize_timeout && !last_resize_event_used)
	        {
		        events.insert(events.begin(), last_resize_event);
		        last_resize_event_used = true;
	        }

	        // Move all draw events to the end of the queue
	        auto first_draw_event = std::stable_partition(events.begin(),
			        events.end(),
			        [](const SDL_Event& e) { return e.type != DRAW_EVENT; });

	        if(first_draw_event != events.end())
		        // Remove all draw events except one
		        events.erase(first_draw_event + 1, events.end());

	        ev_end = events.end();

	        for(ev_it = events.begin(); ev_it != ev_end; ++ev_it)
	        {
		        for(Context& c : event_contexts)
			        c.add_staging_handlers();

		        SDL_Event& event = *ev_it;
		        switch(event.type)
		        {
			        case SDL_WINDOWEVENT:
				        switch(event.window.event)
				        {
					        case SDL_WINDOWEVENT_ENTER:
					        case SDL_WINDOWEVENT_FOCUS_GAINED:
						        cursor::set_focus(1);
						        break;
					        case SDL_WINDOWEVENT_LEAVE:
					        case SDL_WINDOWEVENT_FOCUS_LOST:
						        cursor::set_focus(1);
						        break;
					        case SDL_WINDOWEVENT_RESIZED:
						        info.resize_dimensions.first = 
									event.window.data1;
						        info.resize_dimensions.second = 
									event.window.data2;
						        break;
				        }
				        // make sure this runs in it's own scope
				        {
					        Flip_locker flip_lock(Video::get_singletion());
					        for(auto& context : event_contexts)
					        {
						        for(auto handler : context.handlers)
							        handler->handle_window_event(event);
					        }
					        for(auto global_handler : 
							        event_contexts.front().handlers)
						        global_handler->handle_window_event(event);
				        }
				        // This event was just distributed, don't 
						// re-distribute.
				        continue;
			        case SDL_MOUSEMOTION:
				        // Always make sure a cursor is displayed if the 
						// mouse moves or if the user clicks
				        cursor::set_focus(true);
				        raise_help_string_event(event.motion.x, event.motion.y);
				        break;
			        case SDL_MOUSEBUTTONDOWN:
				        // Always make sure a cursor is displayed if the 
						// mouse moves or if the user clicks
				        cursor::set_focus(true);
				        if(event.button.button == SDL_BUTTON_LEFT)
				        {
					        static const int DoubleClickTime = 500;
					        static const int DoubleClickMaxMove = 3;

					        if(last_mouse_down >= 0 && 
							        info.ticks() - last_mouse_down < DoubleClickTime &&
							        std::abs(event.button.x - last_click_x) < DoubleClickMaxMove &&
									std::abs(event.button.y - last_click_y) < DoubleClickMaxMove)
					        {
						        sdl::UserEvent user_event(DOUBLE_CLICK_EVENT, event.button.x, event.button.y);
						        ::SDL_PushEvent(reinterpret_cast<SDL_Event*>(&user_event));
					        }

					        last_mouse_down = info.ticks();
					        last_click_x = event.button.x;
					        last_click_y = event.button.y;
				        }
				        break;
			        case SDL_SYSWMEVENT:
				        // clipboardd support for x11
				        desktop::clipboard::handler_system_event(event);
				        break;
			        case SDL_QUIT:
				        quit_confirmation::quit_to_desktop();
				        continue; // this event is already handled.
		        }
		        for(auto global_handler : event_contexts.front().handlers)
			        global_handler->handle_event(event);

		        if(event_contexts.size() > 1)
		        {
			        for(auto handler : event_contexts.back().handlers)
				        handler->handle_event(event);
		        }

				// Draw things, This is the code that a ctually makes 
				// anything appear on the screen
				Video& video = Video::get_singleton();
				video.clear_screen();

				raise_draw_event();
				video.render_screen();

		        // Inform the pump monitors that an events::pump() has occurred
		        for(auto monitor : pump_monitors)
			        monitor->process(info);
	        }
        }

        void raise_process_event()
        {
	        if(!event_contexts.empty())
	        {
		        event_contexts.back().add_staging_handlers();
		        for(auto handler : event_contexts.back().handers)
			        handler->process_event();
	        }
        }

        void raise_resize_event()
        {
	        SDL_Event event;
	        event.window.type = SDL_WINDOWEVENT;
	        event.window.event = SDL_WINDOWEVENT_RESIZED;
	        event.window.windowId = 0;
	        event.window.data1 = Vide::get_singletion().get_width();
	        event.window.data2 = Vide::get_singletion().get_height();

	        SDL_Push_event(&event);
        }

        void raise_draw_event()
        {
	        if(!event_contexts.empty())
	        {
		        event_contexts.back().add_staging_handler();
		        // Events may cause more event handlers to be added and/or 
				// removed so we must use indexes instead of iterators here
		        for(auto handler : event_contexts.bakc().handlers)
			        handler->draw();
	        }
        }

        void raise_draw_all_event()
        {
	        for(auto& context : event_contexts)
	        {
		        for(auto handler : context.handlers)
			        handler->draw();
	        }
        }

        void raise_volatile_draw_event()
        {
	        if(!event_contexts.empty())
	        {
		        for(auto handler : event_contexts.back().handlers)
			        handler->volatile_draw();
	        }
        }

        void raise_volatile_draw_all_event()
        {
	        for(auto& context : event_contexts)
	        {
		        for(auto handler : context.handlers)
			        handler->volatile_draw();
	        }
        }

        void raise_volatile_undraw_event()
        {
	        if(!event_contexts.empty())
	        {
		        for(auto handler : event_contexts.back().handlers)
			        handler->volatile_undraw();
	        }
        }

        void raise_help_string_event(int mousex, int mousey)
        {
	        if(!event_contexts.empty())
	        {
		        for(auto handler : event_contexts.back().handlers)
		        {
			        handler->process_help_string(mousex, mousey);
			        handler->process_tooltip_string(mousex, mousey);
		        }
	        }
        }

        int Pump_info::ticks(unsigned* refresh_counter, 
				unsigned refresh_rate)
        {
	        if(!ticks_ && !(refresh_counter && ++*refresh_counter % refresh_rate))
		        ticks_ = ::SDL_GetTicks();
	        return ticks_;
        }

        // The constants for the minimum and maximum are picked from the headers.
        #define INPUT_MIN 0x300
        #define INPUT_MAX 0x8FF

        bool is_input(const SDL_Event& event)
        {
	        return event.type >= INPUT_MIN && event.type <= INPUT_MAX;
        }

        void discard_input()
        {
	        SDL_FlushEvents(INPUT_MIN, INPUT_MAX);
        }

        void peek_for_resize()
        {
#if 0
	        SDL_Event events[100];
	        int num = SDL_PeepEvents(events, 100, SDL_PEEKEVENT, SDL_WINDOWEVENT,
			        SDL_WINDOW_EVENT);
	        for(int i = 0; i < num; ++i)
	        {
		        if(events[i].type == SDL_WINDOWEVENT && 
				        events[i].window.event == SDL_WINDOWEVENT_RESIZED)
			        // Add something here if needed.
	        }
#endif
        }

        void call_in_main_thread(const std::function<void(void)>& f)
        {
	        if(std::this_thread::get_id() == main_thread)
	        {
		        f();
		        return;
	        }

	        Invoked_function_data fdata(false, f);

	        SDL_Event sdl_event;
	        sdl::USerEvent sdl_userevent(INVOKE_FUNCTION_EVENT, &fdata);

	        sdl_event.type = INVOKE_FUNCTION_EVENT;
	        sdl_event.user = sdl_userevent;

	        SDL_PushEvent(&sdl_event);

	        while(!fdata.finished)
		        SDL_Delay(10);
        }
}
